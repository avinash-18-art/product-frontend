{"ast":null,"code":"const {\n  Transform\n} = require('stream');\nconst [cr] = Buffer.from('\\r');\nconst [nl] = Buffer.from('\\n');\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({\n    header\n  }) => header,\n  mapValues: ({\n    value\n  }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false,\n  outputByteOffset: false\n};\nclass CsvParser extends Transform {\n  constructor(opts = {}) {\n    super({\n      objectMode: true,\n      highWaterMark: 16\n    });\n    if (Array.isArray(opts)) opts = {\n      headers: opts\n    };\n    const options = Object.assign({}, defaults, opts);\n    options.customNewline = options.newline !== defaults.newline;\n    for (const key of ['newline', 'quote', 'separator']) {\n      if (typeof options[key] !== 'undefined') {\n        [options[key]] = Buffer.from(options[key]);\n      }\n    }\n\n    // if escape is not defined on the passed options, use the end value of quote\n    options.escape = (opts || {}).escape ? Buffer.from(options.escape)[0] : options.quote;\n    this.state = {\n      empty: options.raw ? Buffer.alloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    };\n    this._prev = null;\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false;\n    }\n    if (options.headers || options.headers === false) {\n      this.state.first = false;\n    }\n    this.options = options;\n    this.headers = options.headers;\n    this.bytesRead = 0;\n  }\n  parseCell(buffer, start, end) {\n    const {\n      escape,\n      quote\n    } = this.options;\n    // remove quotes from quoted cells\n    if (buffer[start] === quote && buffer[end - 1] === quote) {\n      start++;\n      end--;\n    }\n    let y = start;\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n        i++;\n      }\n      if (y !== i) {\n        buffer[y] = buffer[i];\n      }\n      y++;\n    }\n    return this.parseValue(buffer, start, y);\n  }\n  parseLine(buffer, start, end) {\n    const {\n      customNewline,\n      escape,\n      mapHeaders,\n      mapValues,\n      quote,\n      separator,\n      skipComments,\n      skipLines\n    } = this.options;\n    end--; // trim newline\n    if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n      end--;\n    }\n    const comma = separator;\n    const cells = [];\n    let isQuoted = false;\n    let offset = start;\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#';\n      if (buffer[start] === Buffer.from(char)[0]) {\n        return;\n      }\n    }\n    const mapValue = value => {\n      if (this.state.first) {\n        return value;\n      }\n      const index = cells.length;\n      const header = this.headers[index];\n      return mapValues({\n        header,\n        index,\n        value\n      });\n    };\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buffer[i] === quote;\n      const isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma;\n      const isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote;\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted;\n        continue;\n      } else if (isEscape) {\n        i++;\n        continue;\n      }\n      if (buffer[i] === comma && !isQuoted) {\n        let value = this.parseCell(buffer, offset, i);\n        value = mapValue(value);\n        cells.push(value);\n        offset = i + 1;\n      }\n    }\n    if (offset < end) {\n      let value = this.parseCell(buffer, offset, end);\n      value = mapValue(value);\n      cells.push(value);\n    }\n    if (buffer[end - 1] === comma) {\n      cells.push(mapValue(this.state.empty));\n    }\n    const skip = skipLines && skipLines > this.state.lineNumber;\n    this.state.lineNumber++;\n    if (this.state.first && !skip) {\n      this.state.first = false;\n      this.headers = cells.map((header, index) => mapHeaders({\n        header,\n        index\n      }));\n      this.emit('headers', this.headers);\n      return;\n    }\n    if (!skip && this.options.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers');\n      this.emit('error', e);\n    } else {\n      if (!skip) {\n        const byteOffset = this.bytesRead - buffer.length + start;\n        this.writeRow(cells, byteOffset);\n      }\n    }\n  }\n  parseValue(buffer, start, end) {\n    if (this.options.raw) {\n      return buffer.slice(start, end);\n    }\n    return buffer.toString('utf-8', start, end);\n  }\n  writeRow(cells, byteOffset) {\n    const headers = this.headers === false ? cells.map((value, index) => index) : this.headers;\n    const row = cells.reduce((o, cell, index) => {\n      const header = headers[index];\n      if (header === null) return o; // skip columns\n      if (header !== undefined) {\n        o[header] = cell;\n      } else {\n        o[`_${index}`] = cell;\n      }\n      return o;\n    }, {});\n    if (this.options.outputByteOffset) {\n      this.push({\n        row,\n        byteOffset\n      });\n    } else {\n      this.push(row);\n    }\n  }\n  _flush(cb) {\n    if (this.state.escaped || !this._prev) return cb();\n    this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1); // plus since online -1s\n    cb();\n  }\n  _transform(data, enc, cb) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data);\n    }\n    const {\n      escape,\n      quote\n    } = this.options;\n    let start = 0;\n    let buffer = data;\n    this.bytesRead += data.byteLength;\n    if (this._prev) {\n      start = this._prev.length;\n      buffer = Buffer.concat([this._prev, data]);\n      this._prev = null;\n    }\n    const bufferLength = buffer.length;\n    for (let i = start; i < bufferLength; i++) {\n      const chr = buffer[i];\n      const nextChr = i + 1 < bufferLength ? buffer[i + 1] : null;\n      this.state.rowLength++;\n      if (this.state.rowLength > this.options.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'));\n      }\n      if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n        this.state.escaped = true;\n        continue;\n      } else if (chr === quote) {\n        if (this.state.escaped) {\n          this.state.escaped = false;\n          // non-escaped quote (quoting the cell)\n        } else {\n          this.state.quoted = !this.state.quoted;\n        }\n        continue;\n      }\n      if (!this.state.quoted) {\n        if (this.state.first && !this.options.customNewline) {\n          if (chr === nl) {\n            this.options.newline = nl;\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.options.newline = cr;\n            }\n          }\n        }\n        if (chr === this.options.newline) {\n          this.parseLine(buffer, this.state.previousEnd, i + 1);\n          this.state.previousEnd = i + 1;\n          this.state.rowLength = 0;\n        }\n      }\n    }\n    if (this.state.previousEnd === bufferLength) {\n      this.state.previousEnd = 0;\n      return cb();\n    }\n    if (bufferLength - this.state.previousEnd < data.length) {\n      this._prev = data;\n      this.state.previousEnd -= bufferLength - data.length;\n      return cb();\n    }\n    this._prev = buffer;\n    cb();\n  }\n}\nmodule.exports = opts => new CsvParser(opts);","map":{"version":3,"names":["Transform","require","cr","Buffer","from","nl","defaults","escape","headers","mapHeaders","header","mapValues","value","newline","quote","raw","separator","skipComments","skipLines","maxRowBytes","Number","MAX_SAFE_INTEGER","strict","outputByteOffset","CsvParser","constructor","opts","objectMode","highWaterMark","Array","isArray","options","Object","assign","customNewline","key","state","empty","alloc","escaped","first","lineNumber","previousEnd","rowLength","quoted","_prev","bytesRead","parseCell","buffer","start","end","y","i","parseValue","parseLine","length","comma","cells","isQuoted","offset","char","mapValue","index","isStartingQuote","isEndingQuote","isEscape","push","skip","map","emit","e","RangeError","byteOffset","writeRow","slice","toString","row","reduce","o","cell","undefined","_flush","cb","_transform","data","enc","byteLength","concat","bufferLength","chr","nextChr","Error","module","exports"],"sources":["C:/Users/Avinash/node_modules/csv-parser/index.js"],"sourcesContent":["const { Transform } = require('stream')\n\nconst [cr] = Buffer.from('\\r')\nconst [nl] = Buffer.from('\\n')\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({ header }) => header,\n  mapValues: ({ value }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false,\n  outputByteOffset: false\n}\n\nclass CsvParser extends Transform {\n  constructor (opts = {}) {\n    super({ objectMode: true, highWaterMark: 16 })\n\n    if (Array.isArray(opts)) opts = { headers: opts }\n\n    const options = Object.assign({}, defaults, opts)\n\n    options.customNewline = options.newline !== defaults.newline\n\n    for (const key of ['newline', 'quote', 'separator']) {\n      if (typeof options[key] !== 'undefined') {\n        ([options[key]] = Buffer.from(options[key]))\n      }\n    }\n\n    // if escape is not defined on the passed options, use the end value of quote\n    options.escape = (opts || {}).escape ? Buffer.from(options.escape)[0] : options.quote\n\n    this.state = {\n      empty: options.raw ? Buffer.alloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    }\n\n    this._prev = null\n\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false\n    }\n\n    if (options.headers || options.headers === false) {\n      this.state.first = false\n    }\n\n    this.options = options\n    this.headers = options.headers\n    this.bytesRead = 0\n  }\n\n  parseCell (buffer, start, end) {\n    const { escape, quote } = this.options\n    // remove quotes from quoted cells\n    if (buffer[start] === quote && buffer[end - 1] === quote) {\n      start++\n      end--\n    }\n\n    let y = start\n\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n        i++\n      }\n\n      if (y !== i) {\n        buffer[y] = buffer[i]\n      }\n      y++\n    }\n\n    return this.parseValue(buffer, start, y)\n  }\n\n  parseLine (buffer, start, end) {\n    const { customNewline, escape, mapHeaders, mapValues, quote, separator, skipComments, skipLines } = this.options\n\n    end-- // trim newline\n    if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n      end--\n    }\n\n    const comma = separator\n    const cells = []\n    let isQuoted = false\n    let offset = start\n\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#'\n      if (buffer[start] === Buffer.from(char)[0]) {\n        return\n      }\n    }\n\n    const mapValue = (value) => {\n      if (this.state.first) {\n        return value\n      }\n\n      const index = cells.length\n      const header = this.headers[index]\n\n      return mapValues({ header, index, value })\n    }\n\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buffer[i] === quote\n      const isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma\n      const isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote\n\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted\n        continue\n      } else if (isEscape) {\n        i++\n        continue\n      }\n\n      if (buffer[i] === comma && !isQuoted) {\n        let value = this.parseCell(buffer, offset, i)\n        value = mapValue(value)\n        cells.push(value)\n        offset = i + 1\n      }\n    }\n\n    if (offset < end) {\n      let value = this.parseCell(buffer, offset, end)\n      value = mapValue(value)\n      cells.push(value)\n    }\n\n    if (buffer[end - 1] === comma) {\n      cells.push(mapValue(this.state.empty))\n    }\n\n    const skip = skipLines && skipLines > this.state.lineNumber\n    this.state.lineNumber++\n\n    if (this.state.first && !skip) {\n      this.state.first = false\n      this.headers = cells.map((header, index) => mapHeaders({ header, index }))\n\n      this.emit('headers', this.headers)\n      return\n    }\n\n    if (!skip && this.options.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers')\n      this.emit('error', e)\n    } else {\n      if (!skip) {\n        const byteOffset = this.bytesRead - buffer.length + start\n        this.writeRow(cells, byteOffset)\n      }\n    }\n  }\n\n  parseValue (buffer, start, end) {\n    if (this.options.raw) {\n      return buffer.slice(start, end)\n    }\n\n    return buffer.toString('utf-8', start, end)\n  }\n\n  writeRow (cells, byteOffset) {\n    const headers = (this.headers === false) ? cells.map((value, index) => index) : this.headers\n\n    const row = cells.reduce((o, cell, index) => {\n      const header = headers[index]\n      if (header === null) return o // skip columns\n      if (header !== undefined) {\n        o[header] = cell\n      } else {\n        o[`_${index}`] = cell\n      }\n      return o\n    }, {})\n\n    if (this.options.outputByteOffset) {\n      this.push({ row, byteOffset })\n    } else {\n      this.push(row)\n    }\n  }\n\n  _flush (cb) {\n    if (this.state.escaped || !this._prev) return cb()\n    this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1) // plus since online -1s\n    cb()\n  }\n\n  _transform (data, enc, cb) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data)\n    }\n\n    const { escape, quote } = this.options\n    let start = 0\n    let buffer = data\n    this.bytesRead += data.byteLength\n\n    if (this._prev) {\n      start = this._prev.length\n      buffer = Buffer.concat([this._prev, data])\n      this._prev = null\n    }\n\n    const bufferLength = buffer.length\n\n    for (let i = start; i < bufferLength; i++) {\n      const chr = buffer[i]\n      const nextChr = i + 1 < bufferLength ? buffer[i + 1] : null\n\n      this.state.rowLength++\n      if (this.state.rowLength > this.options.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'))\n      }\n\n      if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n        this.state.escaped = true\n        continue\n      } else if (chr === quote) {\n        if (this.state.escaped) {\n          this.state.escaped = false\n          // non-escaped quote (quoting the cell)\n        } else {\n          this.state.quoted = !this.state.quoted\n        }\n        continue\n      }\n\n      if (!this.state.quoted) {\n        if (this.state.first && !this.options.customNewline) {\n          if (chr === nl) {\n            this.options.newline = nl\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.options.newline = cr\n            }\n          }\n        }\n\n        if (chr === this.options.newline) {\n          this.parseLine(buffer, this.state.previousEnd, i + 1)\n          this.state.previousEnd = i + 1\n          this.state.rowLength = 0\n        }\n      }\n    }\n\n    if (this.state.previousEnd === bufferLength) {\n      this.state.previousEnd = 0\n      return cb()\n    }\n\n    if (bufferLength - this.state.previousEnd < data.length) {\n      this._prev = data\n      this.state.previousEnd -= (bufferLength - data.length)\n      return cb()\n    }\n\n    this._prev = buffer\n    cb()\n  }\n}\n\nmodule.exports = (opts) => new CsvParser(opts)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}